#!/bin/sh
# Copyright 2023 Northern.tech AS
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

MODULE_CONFIG_FILE="/etc/mender/mender-app-k8s.conf"

if test -f "$MODULE_CONFIG_FILE"; then
    . "$MODULE_CONFIG_FILE"
fi

kubectl_cmd=${KUBECTL_COMMAND:-"kubectl"}
ctr_cmd=${CTR_COMMAND:-"ctr"}
ctr_image_flags="-n=k8s.io"

delta_executable=${XDELTA_COMMAND:-"xdelta3"}
delta_arguments=${XDELTA_ARGS:-"-d -s"}
delta_cmd="${delta_executable} ${delta_arguments}"

if test "${K8S_NAMESPACE}" != ""; then
    namespace_argument="--namespace=${K8S_NAMESPACE}"
fi

if test "${K8S_CTR_ADDRESS}" != ""; then
    address_argument="--address ${K8S_CTR_ADDRESS}"
fi

if test "${MENDER_APP_UPDATE_MODULE_PLATFORM}" != ""; then
    # multiple platforms: we can support them via MENDER_APP_UPDATE_MODULE_PLATFORM=linux/arm64/v8,linux/arm/v7
    # and split into: platform_argument="--platform \"linux/arm64/v8\" --platform \"linux/arm/v7\""
    platform_argument="--platform ${MENDER_APP_UPDATE_MODULE_PLATFORM}"
fi

# image.img
#    |-- blobs
#    |   `-- sha256
#    |       |-- 1e72ff2f71d79570502c6a6e3b97d4a448e6877e456d571842ca3797da5e9f08.current
#    |       |-- 1e72ff2f71d79570502c6a6e3b97d4a448e6877e456d571842ca3797da5e9f08.new
#    |       |-- 1e72ff2f71d79570502c6a6e3b97d4a448e6877e456d571842ca3797da5e9f08.vcdiff
apply_blob_delta() {
    set -x
    local current_image_dir="$1"
    local new_image_dir="$2"
    local vcdiff="$3"
    local blob_name
    local current

    blob_name=$(basename "$vcdiff" | sed -e 's/\.vcdiff$//')
    current="$current_image_dir"/blobs/$(cat "$new_image_dir"/blobs/sha256/"${blob_name}".current)
    mv -f "$current" "$current".gz
    gzip -d "$current".gz
    $delta_cmd "$current" "${vcdiff}" "$new_image_dir"/blobs/sha256/"${blob_name}" || { echo "apply_blob_delta bp0"; sleep 65536; }
    gzip "$new_image_dir"/blobs/sha256/"${blob_name}"
    mv -f "$new_image_dir"/blobs/sha256/"${blob_name}".gz "$new_image_dir"/blobs/sha256/"${blob_name}"
    rm -f "$new_image_dir"/blobs/sha256/"${blob_name}".current
    rm -f "$new_image_dir"/blobs/sha256/"${blob_name}".new
    rm -f "$new_image_dir"/blobs/sha256/"${blob_name}".vcdiff
}

unpack_image() {
    local input_file="$1"
    local image_dir="$2"

    if test -d "${image_dir}"; then
        rm -Rf "${image_dir}"
    fi
    mkdir -p "${image_dir}"
    tar xvf "$input_file" -C "${image_dir}"
}

resolve_deep_delta() {
    local application_name="$1"
    local input_file="$2"
    local current_url="$3"
    local new_image_dir="${MODULE_TMPDIR:-${TMPDIR}}"
    local current_image_dir="${MODULE_TMPDIR:-${TMPDIR}}"
    local current_image_file
    local vcdiff
    local image_dir="${MODULE_TMPDIR:-${TMPDIR}}"

    if test ! -d "$new_image_dir"; then
        echo "ERROR: neither MODULE_TMPDIR or TMPDIR is set"
        return 1
    fi
    if test ! -d "$current_image_dir"; then
        echo "ERROR: neither MODULE_TMPDIR or TMPDIR is set"
        return 1
    fi
    if test ! -d "$image_dir"; then
        echo "ERROR: neither MODULE_TMPDIR or TMPDIR is set"
        return 1
    fi
    current_image_file="${image_dir}"/$(echo "${current_url}" | sha256sum | cut -f1 -d' ')
    if test -f "$current_image_file"; then
        rm -f "${current_image_file}"
    fi
    set -x
    app_save "${application_name}" "$current_url" "${current_image_file}"
    new_image_dir="${image_dir}/image-$(sha256sum "${input_file}" | cut -f1 -d' ')"
    current_image_dir="${image_dir}/image-$(sha256sum "${current_image_file}" | cut -f1 -d' ')"
    set -x
    unpack_image "${input_file}" "${new_image_dir}"
    unpack_image "${current_image_file}" "${current_image_dir}"
    for vcdiff in "${new_image_dir}"/blobs/sha256/*.vcdiff; do
        if test ! -f "$vcdiff"; then
            break
        fi
        apply_blob_delta "${current_image_dir}" "${new_image_dir}" "${vcdiff}"
    done
    rm -f "${input_file}"
    tar cf "${input_file}" -C "${new_image_dir}" .
}

app_load() {
    local application_name="$1"
    local url="$2"
    local input_file="$3"
    local url_current="$4"

    if test "$OPTIONS" = "deep_delta"; then
        if test "$MODULE_TMPDIR" = ""; then
            echo "ERROR: ${MODULE_TMPDIR} cant be empty"
            return 1
        fi
        if ! test -d "$MODULE_TMPDIR"; then
            echo "ERROR: ${MODULE_TMPDIR} does not exist as a directory"
            return 1
        fi
        resolve_deep_delta "${application_name}" "${input_file}" "${url_current}"
    fi

    $ctr_cmd $ctr_image_flags $address_argument image import "$input_file" $platform_argument 1>&2
}

app_save() {
    local application_name="$1"
    local url="$2"
    local output_file="$3"

    set -x
    $ctr_cmd $address_argument image export $platform_argument "$output_file" "$url" 1>&2
    set +x
}

create_ns_if_needed() {
    local ns="${1}"

    if test "$ns" = ""; then
        return 0
    fi

    $kubectl_cmd get namespaces --field-selector "metadata.name=${ns}" --no-headers | grep -q "$ns"
    if test $? -ne 0; then
        $kubectl_cmd create namespace "$ns" 1>&2
    fi
}

app_rollout() {
    local application_name="$1"
    local manifests_dir="$2"
    local rc=0

    create_ns_if_needed "$K8S_NAMESPACE"
    $kubectl_cmd apply -Rf "${manifests_dir}" $namespace_argument 1>&2
    rc="$?"

    if test "$rc" != "0"; then
        echo "app_rollout failed to apply the manifest with $kubectl_cmd apply -Rf ${manifests_dir} ${namespace_argument} " 1>&2
        return $rc
    fi
    return 0
}

app_stop() {
    local application_name="$1"
    local manifests_dir="$2"

    $kubectl_cmd delete -Rf "${manifests_dir}" "$namespace_argument" 1>&2 || true
}

app_requirements() {
    local rc=0
    $kubectl_cmd version > /dev/null
    rc=$?
    if test $rc -ne 0; then
        echo "error: cannot find command \"${kubectl_cmd}\" in PATH"
        echo "error: are k8s installed?"
        return $rc
    fi
    $ctr_cmd $address_argument --version > /dev/null
    rc=$?
    if test $rc -ne 0; then
        echo "error: cannot find command \"${ctr_cmd}\" in PATH"
        echo "error: is containerd cli installed?"
        return $rc
    fi
    return $rc
}

case "$1" in
    SAVE)
        shift
        app_save "$@"
        ;;
    LOAD)
        shift
        app_load "$@"
        ;;
    ROLLOUT)
        shift
        app_rollout "$@"
        ;;
    STOP)
        shift
        app_stop "$@"
        ;;
    EXPORT_MANIFEST)
        true
        ;;
    LS_COMPONENTS)
        true
        ;;
    DELETE)
        true
        ;;
    ROLLBACK)
        true
        ;;
    PURGE)
        true
        ;;
    START)
        true
        ;;
    ALIVE)
        true
        ;;
    HEALTHY)
        true
        ;;
    REQS)
        shift
        app_requirements
        ;;
    *)
        echo "ERROR: unknown API call: $@"
        exit 1
        ;;
esac
